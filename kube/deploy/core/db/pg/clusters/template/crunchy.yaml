---
apiVersion: postgres-operator.crunchydata.com/v1beta1
kind: PostgresCluster
metadata:
  name: &name "pg-${PG_APP_NAME}"
  namespace: "${PG_APP_NS}"
spec:
  postgresVersion: 16
  patroni: # turn on sync writes to at least 1 other replica
    dynamicConfiguration:
      synchronous_mode: true
      postgresql:
        synchronous_commit: "on"
  instances:
    - name: &instance "${PG_APP_NAME}"
      metadata:
        labels:
          egress.home.arpa/apiserver: "allow"
          egress.home.arpa/r2: "allow"
      replicas: ${PG_REPLICAS:=3}
      dataVolumeClaimSpec:
        storageClassName: "${PG_SC:=local}"
        accessModes: ["ReadWriteOnce"]
        resources:
          requests:
            storage: "${PG_CONFIG_SIZE:=20Gi}"
      topologySpreadConstraints:
        - maxSkew: 1
          topologyKey: "kubernetes.io/hostname"
          whenUnsatisfiable: "DoNotSchedule"
          labelSelector:
            matchLabels:
              postgres-operator.crunchydata.com/cluster: *name
              postgres-operator.crunchydata.com/instance-set: *instance
  users:
    - name: "${PG_DB_USER:=app}"
      databases: ["${PG_DB_NAME:=app}"]
  backups:
    pgbackrest:
      metadata:
        labels:
          egress.home.arpa/apiserver: "allow"
          egress.home.arpa/r2: "allow"
      configuration: &brcfg [secret: {name: "pg-${PG_APP_NAME}-secrets"}]
      global: &brflag
        archive-timeout: "60" # sends WAL archive every X seconds
        repo1-retention-full-type: "time"
        repo1-retention-full: "30"
        repo1-retention-diff: "48"
        repo2-bundle: "y"
        repo2-block: "y"
        repo2-path: "/${PG_APP_NAME}"
        repo2-s3-uri-style: "path"
        repo2-retention-full-type: "time"
        repo2-retention-full: "5"
        repo2-retention-diff: "30"
        repo2-cipher-type: "aes-256-cbc"
      manual:
        repoName: "repo2"
        options: ["--type=full"]
      repos:
        - name: "repo1" # NFS
          volume: &nfs
            volumeClaimSpec:
              storageClassName: "pg-${PG_APP_NAME}-wal-nfs"
              volumeName: "pg-${PG_APP_NAME}-wal-nfs"
              accessModes: ["ReadWriteMany"]
              resources:
                requests:
                  storage: "1Mi" # doesn't matter with NFS
          schedules: # more aggressive for NAS (over NFS)
            full: "0 6 * * *" # everyday at 06:00
            differential: "0 * * * *" # every hour
            incremental: "*/5 * * * *" # every 5 minutes
        - name: "repo2" # Cloudflare R2
          s3: &r2
            endpoint: "${SECRET_PGBACKREST_WAL_R2_ENDPOINT}"
            bucket: "${SECRET_PGBACKREST_WAL_R2_BUCKET}"
            region: "us-east-1"
          schedules: # less aggressive for R2 to save on S3 API costs, times staggered to try and avoid NFS schedule to avoid operator spamming failed jobs
            full: "27 6 * * 1" # every monday at 06:27
            differential: "17 6 * * *" # everyday at 06:17
            incremental: "7 * * * *" # every hour at 7th minute
  dataSource:
    pgbackrest:
      stanza: "db"
      configuration: *brcfg
      global: *brflag
      repo:
        name: "repo2"
        s3: *r2
  proxy:
    pgBouncer:
      port: 5432
      replicas: 3
      topologySpreadConstraints:
        - maxSkew: 1
          topologyKey: "kubernetes.io/hostname"
          whenUnsatisfiable: "DoNotSchedule"
          labelSelector:
            matchLabels:
              postgres-operator.crunchydata.com/cluster: *name
              postgres-operator.crunchydata.com/role: "pgbouncer"
---
apiVersion: v1
kind: Secret
metadata:
  name: "pg-${PG_APP_NAME}-secrets"
  namespace: "${PG_APP_NS}"
type: Opaque
stringData:
  s3.conf: |
    [global]
    repo2-s3-key=${SECRET_PGBACKREST_WAL_R2_ID}
    repo2-s3-key-secret=${SECRET_PGBACKREST_WAL_R2_KEY}
  encryption.conf: |
    [global]
    repo2-cipher-pass=${SECRET_PGBACKREST_WAL_ENCRYPT}
